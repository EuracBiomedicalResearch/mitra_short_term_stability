#' 50 ppm. We're extracting the m/z and retention time range for these
#' chromatographic peaks
std_info_mz_rt <- chromPeakArea(data_neg, mz = std_info$mz_ion,
rt = std_info$RT, diffRt = 30,
ppm = 50)
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[as.character(data_neg$storage)]
for (i in 1:nrow(std_info)) {
cmpname <- std_info$name[i]
filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
"_NEG.png")
png(file = filename, width = 16, height = 8, units = "cm",
res = 300, pointsize = 4)
chr <- std_info_chr[i, ]
pks <- chromPeaks(chr)
plot(chr, col = "#00000040",
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
peakCol = paste0(sample_colors[pks[, "column"]], 50),
peakBg = paste0(sample_colors[pks[, "column"]], 10))
## This is just to indicate identified peaks with a rectangle.
xcms:::.add_chromatogram_peaks(
chr, pks,
col = paste0(sample_colors[pks[, "column"]], 40),
bg = NA,
type = "rectangle")
abline(v = std_info$RT[i])
dev.off()
}
#' Go manually through all generated plots above and determine which peaks
#' look OK.
std_info$RT_obs <- NA_real_
std_info$is_ok <- FALSE
std_info$peak_note <- NA_character_
write.table(std_info, file = "data/std_info_neg.txt", row.names = FALSE, sep = "\t")
std_info <- read.table("data/std_info_neg_check.txt", sep = "\t", as.is = TRUE,
header = TRUE, dec = ".")
std_info$mz_ion <- as.numeric(std_info$mz_ion)
std_info <- std_info[std_info$is_ok, ]
std_info_mz_rt <- chromPeakArea(data_neg, mz = std_info$mz_ion,
rt = std_info$RT_obs, diffRt = 1, ppm = 10,
type = "any")
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 5
rtr[, 2] <- rtr[, 2] + 5
std_info_chr <- chromatogram(
data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
rt = rtr, aggregationFun = "max")
#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[data_neg$storage]
for (i in seq_len(nrow(std_info))) {
cmpname <- std_info$name[i]
filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
"_POS.png")
png(file = filename, width = 16, height = 8, units = "cm",
res = 300, pointsize = 4)
chr <- std_info_chr[i, ]
pks <- chromPeaks(chr)
plot(chr, col = "#00000040",
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
peakCol = paste0(sample_colors[pks[, "column"]], 50),
peakBg = paste0(sample_colors[pks[, "column"]], 10))
#' This is just to indicate identified peaks with a rectangle.
xcms:::.add_chromatogram_peaks(
chr, pks,
col = paste0(sample_colors[pks[, "column"]], 40),
bg = NA,
type = "rectangle")
## abline(v = std_info$RT[i])
abline(v = std_info$RT_obs[i], lty = 2)
dev.off()
}
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 5
rtr[, 2] <- rtr[, 2] + 5
std_info_chr <- chromatogram(
data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
rt = rtr, aggregationFun = "max")
#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[data_neg$storage]
for (i in seq_len(nrow(std_info))) {
cmpname <- std_info$name[i]
filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
"_NEG.png")
png(file = filename, width = 16, height = 8, units = "cm",
res = 300, pointsize = 4)
chr <- std_info_chr[i, ]
pks <- chromPeaks(chr)
plot(chr, col = "#00000040",
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
peakCol = paste0(sample_colors[pks[, "column"]], 50),
peakBg = paste0(sample_colors[pks[, "column"]], 10))
#' This is just to indicate identified peaks with a rectangle.
xcms:::.add_chromatogram_peaks(
chr, pks,
col = paste0(sample_colors[pks[, "column"]], 40),
bg = NA,
type = "rectangle")
## abline(v = std_info$RT[i])
abline(v = std_info$RT_obs[i], lty = 2)
dev.off()
}
## Plot EICs for peaks that were merged by the *refinement* step.
load(paste0(RDATA_PATH, "data_neg_pks.RData"))
data_neg_pks <- data_neg
load(paste0(RDATA_PATH, "data_neg_refined.RData"))
merged_rand <- sample(which(chromPeakData(data_neg)$merged), 100)
dr <- paste0(IMAGE_PATH, "random_merged_peaks/")
dir.create(dr, showWarnings = FALSE)
for (i in merged_rand) {
pk <- chromPeaks(data_neg)[i, , drop = FALSE]
rtr <- pk[1, c("rtmin", "rtmax")] + c(-10, 10)
mzr <- pk[1, c("mzmin", "mzmax")] + c(-0.005, 0.005)
chr_1 <- chromatogram(filterFile(data_neg_pks, pk[1, "sample"]),
rt = rtr, mz = mzr)
chr_2 <- chromatogram(filterFile(data_neg, pk[1, "sample"]),
rt = rtr, mz = mzr)
png(file = paste0(dr, rownames(pk), ".png"), width = 12, height = 12,
units = "cm", res = 300, pointsize = 4)
par(mfrow = c(2, 1))
plot(chr_1, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
plot(chr_2, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
dev.off()
}
std_info <- std_info[std_info$is_ok, , drop = FALSE]
#' Calculate summaries on peaks overlapping an MS slice.
#'
#' @return
#'
#' `numeric()` with:
#' - average rt peak width `"rt_width"`
#' - average mz peak width `"mz_width"`
#' - average mz peak width in ppm `"mz_width_ppm"`
#' - average difference of the peak m/z to the theoretical m/z in ppm `"mz_ppm"`
#' - number of samples in which more than one peak was found `"multi_pk_count"`
#' - percentage of samples within each group in which a peak was found.
slice_peak_summary <- function(rtr, mzr, mz = NULL, x, group, ppm = 10) {
if (missing(group))
group <- rep("all", length(fileNames(x)))
group <- factor(group, levels = unique(group))
if (missing(x))
stop("'x' has to be submitted.")
pks <- chromPeaks(x, rt = rtr, mz = mzr, ppm = ppm)
if (nrow(pks)) {
pks <- cbind(pks,
rt_width = pks[, "rtmax"] - pks[, "rtmin"],
mz_width = pks[, "mzmax"] - pks[, "mzmin"])
pks <- cbind(pks,
mz_width_ppm = pks[, "mz_width"] * 1e6 / pks[, "mz"])
if (length(mz))
mz_ppm <- mean(abs(pks[, "mz"] - mz) * 1e6 / mz)
else mz_ppm <- NA_real_
#' Number of samples in which multiple peaks were identified.
pk_cnt_smpl <- table(factor(pks[, "sample"],
levels = 1:length(fileNames(x))))
#' Percentage per source in which a peak was identified.
pk_perc <- split(as.numeric(pk_cnt_smpl), group)
percs <- unlist(lapply(pk_perc, function(z) 100 * sum(z > 0) / length(z)))
c(rt_width = mean(pks[, "rt_width"]),
mz_width = mean(pks[, "mz_width"]),
mz_width_ppm = mean(pks[, "mz_width_ppm"]),
mz_ppm = mz_ppm,
multi_pk_count = sum(pk_cnt_smpl > 1),
percs)
} else {
percs <- rep(NA_real_, length(unique(group)))
names(percs) <- unique(group)
c(rt_width = NA_real_, mz_width = NA_real_, mz_width_ppm = NA_real_,
mz_ppm = NA_real_, multi_pk_count = NA_real_, percs)
}
}
#' Iterate through rows to determine statistics for samples:
std_info_pks <- vector("list", nrow(std_info))
for (i in 1:nrow(std_info)) {
rtr <- std_info$RT_obs[i] + c(-7, 7)
mzr <- std_info$mz_ion[i]
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_neg, data_neg$storage, ppm = 50)
if (is.na(res[1]))
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_neg, data_neg$storage, ppm = 100)
std_info_pks[[i]] <- res
}
std_info_pks <- data.frame(name = std_info$name, do.call(rbind, std_info_pks),
stringsAsFactors = FALSE)
std_info_pks$delta_rt <- std_info$RT_obs - std_info$RT
pandoc.table(std_info_pks, style = "rmarkdown",
caption = paste("Summary for identified chromatographic peaks of",
"the known compounds. Columns rt_width, mz_width",
"and mz_width_ppm show the mean widths in",
"retention time and m/z dimension of the",
"peaks, mz_ppm the average difference between",
"the peaks' m/z and the theoretical m/z of the",
"ion, multi_pk_count the number of samples in",
"which more than one peak was identified",
"in the rt region and the remaining columns",
"the percentages of samples per group in which",
"a peak was identified. Columnn delta_rt ",
"contains the difference between the observed ",
"and the expected retention time."))
write.table(std_info_pks, file = "data/std_info_summary_id_peaks.txt", row.names = FALSE, sep = "\t")
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_neg),
chromPeaks(data_neg)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_neg$storage], 80),
ylab = "peak count", main = "Peak detection summary, NEG",
ylim = c(0, 10000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_neg$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_neg$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_neg$storage], 80))
#' Calculate per sample mean of
#' - peak count
#' - m/z width
#' - rt width
#' Aggregate these per sample group.
smpl_summary <- cbind(peak_count = vapply(pk_list, nrow, numeric(1)),
do.call(rbind, lapply(pk_list, function(z) {
c(median_mz_width = median(z[, "mz_width_ppm"]),
median_rt_width = median(z[, "rt_width"]))
})))
tab <- aggregate(smpl_summary, by = list(storage = data_neg$storage), quantile)
rownames(tab) <- tab[, 1]
tab <- tab[, -1]
pandoc.table(t(tab), style = "rmarkdown",
cap = paste("Summary of peak detection results. Shown are the",
"per-source quantiles of the numbers of identified",
"peaks, of the median m/z (in ppm) and rt widths",
" per sample."))
plotChromPeaks(filterMz(data_neg, mz = c(756, 758)), 1)
abline(h = c(757, 757.01), col = "#0000ff80")
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
peak_type = "point", lwd = 1, ...) {
if (missing(rt))
rt <- range(rtime(x))
chr_tmp <- chromatogram(x, mz = mz, rt = rt)
col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
col = paste0(col, 60),
peakCol = paste0(col_tmp, 40),
peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$storage, bw = 1.3)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_neg$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_0.8.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$storage, bw = 1.3)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_neg$storage])
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(160, 170)
pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$storage, bw = 2)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_neg$storage])
mzr <- std_info[std_info$HMDB.code == "HMDB0000001", "mz_ion"] + c(0.002, -0.002)
rtr <- c(170, 200)
plot_grouping(data_neg, rt = rtr, mz = mzr, param = pdp_tmp,
col = col_storage[data_neg$storage])
#' Remove potentially problematic samples. These were manually defined.
#' bad_idx <- c(74, 178, 166, 167, 39, 187, 169, 106)
#' data_neg <- filterFile(data_neg, file = seq_along(data_neg$sample)[-bad_idx])
#' define the peak grouping parameters to define the hook peaks
#' These should be peaks present in most samples
pdp <- PeakDensityParam(sampleGroups = data_neg$storage,
minFraction = 0.95,
minSamples = 5,
binSize = 0.01,
bw = 2)
data_neg <- groupChromPeaks(data_neg, param = pdp)
#' Next we perform the alignemnt.
pgp <- PeakGroupsParam(minFraction = 0.95, extraPeaks = 50, span = 0.3,
subsetAdjust = "average",
subset = which(data_neg$storage == "QC"))
data_neg <- adjustRtime(data_neg, param = pgp)
chr_raw <- chromatogram(data_neg, aggregationFun = "max", adjustedRtime = FALSE)
chr_adj <- chromatogram(data_neg, aggregationFun = "max")
par(mfrow = c(3, 1), mar = c(0, 4.3, 2, 0.1))
plot(chr_raw, col = paste0(col_storage[chr_raw$storage], 40),
peakType = "none", main = "BPC, raw")
plot(chr_adj, col = paste0(col_storage[chr_raw$storage], 40),
peakType = "none", main = "BPC, adjusted")
plotAdjustedRtime(data_neg, col = paste0(col_storage[data_neg$storage], 80),
peakGroupsPch = 1, peakGroupsCol = "#00000040")
#' For each standard, reduce to the peak with the highest intensity within
#' the observed rt +/- 7 seconds.
std_info_mz_rt_obs <- chromPeakArea(data_neg, mz = std_info$mz_ion,
rt = std_info$RT_obs, diffRt = 1,
ppm = 10, type = "any")
rtr <- cbind(std_info_mz_rt_obs[, "rtmin"] - 5,
std_info_mz_rt_obs[, "rtmax"] + 5)
std_info_chr <- chromatogram(
data_neg, mz = std_info_mz_rt_obs[, c("mzmin", "mzmax")],
rt = rtr, aggregationFun = "max")
#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "alignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[data_neg$storage]
for (i in 1:nrow(std_info)) {
cmpname <- std_info$name[i]
filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
"_NEG.png")
png(file = filename, width = 16, height = 8, units = "cm",
res = 300, pointsize = 4)
chr <- std_info_chr[i, ]
pks <- chromPeaks(chr)
plot(chr, col = "#00000040",
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
peakCol = paste0(sample_colors[pks[, "column"]], 50),
peakBg = paste0(sample_colors[pks[, "column"]], 10))
abline(v = std_info$RT_obs[i])
abline(v = std_info$RT[i], lty = 3, col = "grey")
dev.off()
}
save(data_neg, file = paste0(RDATA_PATH, "data_neg_aligned.RData"))
#' Define settings for the correspondence and perform the analysis
pdp <- PeakDensityParam(sampleGroups = data_neg$storage,
minFraction = 1/3,
minSamples = 3,
binSize = 0.015,
bw = 2.3)
data_neg <- groupChromPeaks(data_neg, param = pdp)
std_info_chr <- chromatogram(
data_neg, mz = std_info_mz_rt_obs[, c("mzmin", "mzmax")],
rt = rtr, aggregationFun = "max")
dr <- paste0(IMAGE_PATH, "correspondence/")
dir.create(dr, showWarnings = FALSE)
#' Visualizing alignment results for known compounds.
for (i in seq_len(nrow(std_info))) {
cmpname <- std_info$name[i]
filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
"_NEG.png")
chr <- std_info_chr[i, ]
#' Use a different color for each feature.
n_fts <- nrow(featureDefinitions(chr))
clrs <- brewer.pal(9, "Set1")[seq_len(n_fts)]
fts <- featureDefinitions(chr)
if (nrow(fts)) {
pk_col <- rep("#000000", nrow(chromPeaks(chr)))
for (j in seq_len(n_fts)) {
pk_col[fts$peakidx[[j]]] <- clrs[j]
}
png(filename, width = 12, height = 10, units = "cm",
res = 200, pointsize = 4)
plotChromPeakDensity(chr, simulate = FALSE,
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
peakCol = paste0(pk_col, 40),
peakBg = paste0(pk_col, "10"),
col = "#00000040")
abline(v = std_info$RT[i], col = "#00000080", lty = 3)
abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
} else {
png(filename, width = 12, height = 10, units = "cm",
res = 200, pointsize = 4)
plotChromPeakDensity(chr,
main = paste0(std_info$name[i], ": ",
format(mz(chr)[1], digits = 6), "-",
format(mz(chr)[2], digits = 6)),
param = pdp, col = "#00000040")
abline(v = std_info$RT[i], col = "#00000080", lty = 3)
abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
}
dev.off()
}
#' In addition find for each standard the *best* feature (i.e. closest mz
#' and rt.
std_info$feature_id <- NA_character_
for (i in seq_len(nrow(std_info))) {
fts <- featureDefinitions(data_neg, mz = std_info$mz_ion[i], ppm = 50)
rt_diff <- abs(fts$rtmed - std_info$RT_obs[i])
fts <- fts[rt_diff < 7, ]
mz_diff <- abs(fts$mzmed - std_info$mz_ion[i])
std_info$feature_id[i] <- rownames(fts[order(mz_diff), ])[1]
}
feat_summ <- featureSummary(data_neg, group = data_neg$storage)
#' Summarized the feature summary table by breaking it down to certain
#' categories that represent the total number of features, total number of
#' features with as well as fetures present in certain percentages of samples with the percentages defined with `percentages`.
#'
#' @param x `matrix` such as returned by the [featureSummary] function.
#'
#' @param percentages `numeric` defining the percentages for which counts
#'     should be reported.
#'
#' @return `matrix` with total counts of features and counts of features for
#'     which peaks have been found in certain percentages of samples. Rows
#'     `"multi"` refer to features for which multiple chromatographic peaks
#'     are present in a sample.
#'
#' @author Johannes Rainer
featureSummaryTable <- function(x, percentages = c(10, 25, 50, 90)) {
#' Check input table.
if (!is.matrix(x) ||
!all(c("count", "multi_count", "multi_perc", "perc") %in% colnames(x)))
stop("'x' is supposed to be a matrix as returned by the ",
"'featureSummary' function")
trues <- list(total = feat_summ[, "count"] > 0,
`single peaks` = feat_summ[, "multi_count"] == 0,
`multi peaks` = feat_summ[, "multi_perc"] > 0
)
if (length(percentages)) {
for (perc in percentages) {
trues <- c(trues, list(feat_summ[, "multi_perc"] > perc))
}
names(trues) <- c("total", "single peaks", "multi peaks",
paste0("multi in > ", percentages, "% of samples"))
}
do.call(rbind, lapply(trues, function(is_true) {
cnt <- c(count = sum(is_true))
for (perc in percentages) {
nms <- names(cnt)
cnt <- c(cnt, sum(x[is_true, "perc"] > perc))
names(cnt) <- c(nms, paste0("in > ", perc, "%"))
}
cnt
}))
}
pandoc.table(featureSummaryTable(feat_summ), style = "rmarkdown",
caption = paste("Summary of the correspondence analysis. Shown",
"are counts of features, counts of features with",
"at least one samples in which multiple peaks",
"are present (column multi peaks) and counts",
"of features with different amount of samples",
"having multiple peaks."))
#' We extract the integrated original signal and use the signal from the peak
#' with the larger signal for multi-peak features.
fmat <- featureValues(data_neg, value = "into", method = "maxint")
#' Subset to QC samples and remove features not present in 90% of the samples
fmat_qc <- fmat[, data_neg$storage == "QC"]
nsamp <- ncol(fmat_qc)
fmat_qc <- fmat_qc[apply(fmat_qc, MARGIN = 1,
function(z) (sum(!is.na(z)) / nsamp) >= 0.9), ]
#' Calculat maximal differences...
diff_fun <- function(z) {
c(M_range = diff(range(z, na.rm = TRUE)),
M_98 = unname(diff(quantile(z, probs = c(0.01, 0.99), na.rm = TRUE))),
M_90 = unname(diff(quantile(z, probs = c(0.05, 0.95), na.rm = TRUE))))
}
QC_diffs <- t(apply(log2(fmat_qc), MARGIN = 1, FUN = diff_fun))
tab <- apply(QC_diffs, MARGIN = 2, quantile)
pandoc.table(tab, style = "rmarkdown",
caption = paste("Overview of the abundance differences between",
"QC samples. Shown are quantiles for the M_range",
"(log2 difference between the most extreme values",
"for a feature), M_98 (log2 difference after",
"removing the top 1% and lowest 1% of values for",
"a feature) and M_90 (log2 difference after",
"removing the top and lowest 5% of values per",
"feature). The analysis bases on", nrow(QC_diffs),
"features."))
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 1))
boxplot(QC_diffs, ylab = expression(log[2]~abundance~ratio))
grid(nx = NA, ny = NULL)
plot(rowMeans(log2(fmat_qc), na.rm = TRUE), QC_diffs[, 1],
xlab = expression(log[2]~average~abundance),
ylab = expression(log[2]~abundance~ratio), pch = 16, col = "#00000060")
grid()
save(data_neg, file = paste0(RDATA_PATH, "data_neg.RData"))
sessionInfo()
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(160, 175)
pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$storage, bw = 2)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_neg$storage])
