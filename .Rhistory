plot(chr_1, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
plot(chr_2, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
dev.off()
}
std_info <- std_info[std_info$is_ok, , drop = FALSE]
#' Calculate summaries on peaks overlapping an MS slice.
#'
#' @return
#'
#' `numeric()` with:
#' - average rt peak width `"rt_width"`
#' - average mz peak width `"mz_width"`
#' - average mz peak width in ppm `"mz_width_ppm"`
#' - average difference of the peak m/z to the theoretical m/z in ppm `"mz_ppm"`
#' - number of samples in which more than one peak was found `"multi_pk_count"`
#' - percentage of samples within each group in which a peak was found.
slice_peak_summary <- function(rtr, mzr, mz = NULL, x, group, ppm = 10) {
if (missing(group))
group <- rep("all", length(fileNames(x)))
group <- factor(group, levels = unique(group))
if (missing(x))
stop("'x' has to be submitted.")
pks <- chromPeaks(x, rt = rtr, mz = mzr, ppm = ppm)
if (nrow(pks)) {
pks <- cbind(pks,
rt_width = pks[, "rtmax"] - pks[, "rtmin"],
mz_width = pks[, "mzmax"] - pks[, "mzmin"])
pks <- cbind(pks,
mz_width_ppm = pks[, "mz_width"] * 1e6 / pks[, "mz"])
if (length(mz))
mz_ppm <- mean(abs(pks[, "mz"] - mz) * 1e6 / mz)
else mz_ppm <- NA_real_
#' Number of samples in which multiple peaks were identified.
pk_cnt_smpl <- table(factor(pks[, "sample"],
levels = 1:length(fileNames(x))))
#' Percentage per source in which a peak was identified.
pk_perc <- split(as.numeric(pk_cnt_smpl), group)
percs <- unlist(lapply(pk_perc, function(z) 100 * sum(z > 0) / length(z)))
c(rt_width = mean(pks[, "rt_width"]),
mz_width = mean(pks[, "mz_width"]),
mz_width_ppm = mean(pks[, "mz_width_ppm"]),
mz_ppm = mz_ppm,
multi_pk_count = sum(pk_cnt_smpl > 1),
percs)
} else {
percs <- rep(NA_real_, length(unique(group)))
names(percs) <- unique(group)
c(rt_width = NA_real_, mz_width = NA_real_, mz_width_ppm = NA_real_,
mz_ppm = NA_real_, multi_pk_count = NA_real_, percs)
}
}
#' Iterate through rows to determine statistics for samples:
std_info_pks <- vector("list", nrow(std_info))
for (i in 1:nrow(std_info)) {
rtr <- std_info$RT_obs[i] + c(-7, 7)
mzr <- std_info$mz_ion[i]
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_pos, data_pos$source, ppm = 50)
if (is.na(res[1]))
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_pos, data_pos$source, ppm = 100)
std_info_pks[[i]] <- res
}
std_info <- std_info[std_info$is_ok, , drop = FALSE]
#' Calculate summaries on peaks overlapping an MS slice.
#'
#' @return
#'
#' `numeric()` with:
#' - average rt peak width `"rt_width"`
#' - average mz peak width `"mz_width"`
#' - average mz peak width in ppm `"mz_width_ppm"`
#' - average difference of the peak m/z to the theoretical m/z in ppm `"mz_ppm"`
#' - number of samples in which more than one peak was found `"multi_pk_count"`
#' - percentage of samples within each group in which a peak was found.
slice_peak_summary <- function(rtr, mzr, mz = NULL, x, group, ppm = 10) {
if (missing(group))
group <- rep("all", length(fileNames(x)))
group <- factor(group, levels = unique(group))
if (missing(x))
stop("'x' has to be submitted.")
pks <- chromPeaks(x, rt = rtr, mz = mzr, ppm = ppm)
if (nrow(pks)) {
pks <- cbind(pks,
rt_width = pks[, "rtmax"] - pks[, "rtmin"],
mz_width = pks[, "mzmax"] - pks[, "mzmin"])
pks <- cbind(pks,
mz_width_ppm = pks[, "mz_width"] * 1e6 / pks[, "mz"])
if (length(mz))
mz_ppm <- mean(abs(pks[, "mz"] - mz) * 1e6 / mz)
else mz_ppm <- NA_real_
#' Number of samples in which multiple peaks were identified.
pk_cnt_smpl <- table(factor(pks[, "sample"],
levels = 1:length(fileNames(x))))
#' Percentage per source in which a peak was identified.
pk_perc <- split(as.numeric(pk_cnt_smpl), group)
percs <- unlist(lapply(pk_perc, function(z) 100 * sum(z > 0) / length(z)))
c(rt_width = mean(pks[, "rt_width"]),
mz_width = mean(pks[, "mz_width"]),
mz_width_ppm = mean(pks[, "mz_width_ppm"]),
mz_ppm = mz_ppm,
multi_pk_count = sum(pk_cnt_smpl > 1),
percs)
} else {
percs <- rep(NA_real_, length(unique(group)))
names(percs) <- unique(group)
c(rt_width = NA_real_, mz_width = NA_real_, mz_width_ppm = NA_real_,
mz_ppm = NA_real_, multi_pk_count = NA_real_, percs)
}
}
#' Iterate through rows to determine statistics for samples:
std_info_pks <- vector("list", nrow(std_info))
for (i in 1:nrow(std_info)) {
rtr <- std_info$RT_obs[i] + c(-7, 7)
mzr <- std_info$mz_ion[i]
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_pos, data_pos$storage, ppm = 50)
if (is.na(res[1]))
res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
data_pos, data_pos$storage, ppm = 100)
std_info_pks[[i]] <- res
}
std_info_pks <- data.frame(name = std_info$name, do.call(rbind, std_info_pks),
stringsAsFactors = FALSE)
std_info_pks$delta_rt <- std_info$RT_obs - std_info$RT
pandoc.table(std_info_pks, style = "rmarkdown",
caption = paste("Summary for identified chromatographic peaks of",
"the known compounds. Columns rt_width, mz_width",
"and mz_width_ppm show the mean widths in",
"retention time and m/z dimension of the",
"peaks, mz_ppm the average difference between",
"the peaks' m/z and the theoretical m/z of the",
"ion, multi_pk_count the number of samples in",
"which more than one peak was identified",
"in the rt region and the remaining columns",
"the percentages of samples per group in which",
"a peak was identified. Columnn delta_rt ",
"contains the difference between the observed ",
"and the expected retention time."))
write.table(std_info_pks, file = "data/std_info_summary_id_peaks.txt", row.names = FALSE, sep = "\t")
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_source[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 4000), xaxt = "n")
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 4000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "summary_preprocessing.pdf"), height = 7, width = 7)
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_source[as.character(data_pos$source)], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6004), xaxt = "n")
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 4000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "summary_preprocessing.pdf"), height = 7, width = 7)
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[as.character(data_pos$storage)], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6004), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
dev.off()
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "summary_preprocessing.pdf"), height = 7, width = 7)
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[as.character(data_pos$storage)], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6004), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
dev.off()
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 8000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "summary_preprocessing.pdf"), height = 7, width = 7)
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[as.character(data_pos$storage)], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6004), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
dev.off()
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 10000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "summary_preprocessing.pdf"), height = 7, width = 7)
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[as.character(data_pos$storage)], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 6004), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[as.character(data_pos$storage)], 80))
dev.off()
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
col = paste0(col_storage[data_pos$storage], 80),
ylab = "peak count", main = "Peak detection summary, POS",
ylim = c(0, 10000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
col = paste0(col_storage[data_pos$storage], 80))
#' Calculate per sample mean of
#' - peak count
#' - m/z width
#' - rt width
#' Aggregate these per sample group.
smpl_summary <- cbind(peak_count = vapply(pk_list, nrow, numeric(1)),
do.call(rbind, lapply(pk_list, function(z) {
c(median_mz_width = median(z[, "mz_width_ppm"]),
median_rt_width = median(z[, "rt_width"]))
})))
tab <- aggregate(smpl_summary, by = list(storage = data_pos$storage), quantile)
rownames(tab) <- tab[, 1]
tab <- tab[, -1]
pandoc.table(t(tab), style = "rmarkdown",
cap = paste("Summary of peak detection results. Shown are the",
"per-source quantiles of the numbers of identified",
"peaks, of the median m/z (in ppm) and rt widths",
" per sample."))
plotChromPeaks(filterMz(data_pos, mz = c(756, 758)), 1)
abline(h = c(757, 757.01), col = "#0000ff80")
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
peak_type = "point", lwd = 1, ...) {
if (missing(rt))
rt <- range(rtime(x))
chr_tmp <- chromatogram(x, mz = mz, rt = rt)
col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
col = paste0(col, 60),
peakCol = paste0(col_tmp, 40),
peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_1.8.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
peak_type = "point", lwd = 1, ...) {
if (missing(rt))
rt <- range(rtime(x))
chr_tmp <- chromatogram(x, mz = mz, rt = rt)
col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
col = paste0(col, 60),
peakCol = paste0(col_tmp, 40),
peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.0)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_1.0.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.0)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
peak_type = "point", lwd = 1, ...) {
if (missing(rt))
rt <- range(rtime(x))
chr_tmp <- chromatogram(x, mz = mz, rt = rt)
col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
col = paste0(col, 60),
peakCol = paste0(col_tmp, 40),
peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 0.8)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_0.8.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 0.8)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
peak_type = "point", lwd = 1, ...) {
if (missing(rt))
rt <- range(rtime(x))
chr_tmp <- chromatogram(x, mz = mz, rt = rt)
col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
col = paste0(col, 60),
peakCol = paste0(col_tmp, 40),
peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_0.8.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$source, bw = 2)
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 2)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_source[data_pos$source])
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 2)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
col = col_storage[data_pos$storage])
xcms
package_info(xcms)
