---
title: "Preprocessing of mitra short term stability data"
subtitle: "positive polarity"
author: "Christa Malfertheiner"
graphics: yes
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis" }
library('knitr')
library(BiocStyle)
BiocStyle::markdown() 
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Modified**: `r file.info("vams_preprocessing.Rmd")$mtime`<br />
**Compiled**: `r date()`


```{r settings, echo = FALSE, results = "hide", message = FALSE}
#' Set general options
options(useFancyQuotes = FALSE)
set.seed(123)
## Setting golden ratio to save images
phi <- (1+sqrt(5))/2
#' Define paths:
filename <- "sts_preprocessing_pos"
#' Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH))
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)
#' Define the path where we can find the mzML files:
MZML_PATH <- "C:/Users/User/Documents/sts_mzML_pos"
## MZML_PATH <- "/data/massspec/mzML/2018/"
if (!file.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)
#' Where to cut the chromatogram (i.e. subset to spectra within rt 0-rt_cut)
rt_cut <- 340
#' Get the number of cpus allocated or fall back to 3 
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
#' Whether or not to plot the EICs for all standards - takes loooong time
plot_eics <- TRUE
```

# Abstract

In this document we perform the analysis on short term stability data collected
with mitra tips, using the `MSnbase` package for MS data import and handling 
and the `xcms` package to perform quality assessment, peak detection, alignment
and correspondence on said data.
The following code allows preprocessing of data registered in positive ion mode.


# Introduction
 
In this section we perform the pre-processing of the untargeted metabolomics
data on short term stability data collected with mitra tips which comprises an
initial quality assessment, chromatographic peak detection, alignment 
(retention time correction) and correspondence (chromatographic peak grouping 
across samples).

In the project the impact of different storage conditions on metabolite 
concentrations is investigated.

The input files represent centroided data, with centroiding performed using the
`MSnbase` package based on the following settings: smoothing of the signal in
retention time dimension by averaging signal from 3 neighboring spectra in a
moving window approach followed by smoothing of each spectrum (along the m/z
dimension) using a Savitzky-Golay filter with a half window size of 6. The data
was subsequently centroided refining in addition the centroid's m/z value with
an intensity-weighted average of m/z values for signal within the peak with at
least 33% of the centroid's intensity.

# Positive polarity

We first focus on the data in positive polarity.

## Raw data import and initial quality assessment

Below we load all required libraries for the analysis as well as the *phenodata*
file defining the experiment's layout and we define some general settings, such
as `da`, which describes the tolerance for the m/z ratio, and `RTd`, which 
describes the tolerance for the retention
time; both these parameters will be used later in the analysis. Also, we set up
the parallel processing,
define colors to be used for the various experimental groups throughout the
experiment and finally read the raw data.

```{r pos-libraries-data, message = FALSE}
library(xcms)
library(RColorBrewer)
library(devtools)
library(pander)
library(pheatmap)
library(MsCoreUtils)
library(Rdisop)
library(CompMetaboTools)
library(doParallel)
library(magrittr)
library(readxl)
library(MsCoreUtils)
## Define some general settings
da <- 0.01
RTd <- 30
## Use socket based parallel processing on Windows systems
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(ncores)))
} else {
    register(bpstart(SnowParam(ncores)))
}
pd <- read.table("data/mitra-short-term-files.txt", sep = "\t", as.is = TRUE, header = TRUE)
pd_pos <- pd[pd$polarity == "POS", ]
#' Define colors for the groups.
col_storage <- brewer.pal(6, name = "Set1")
names(col_storage) <- c("4C_BAG",   # red
                       "RT",        # blue
                       "BAG",       # green
                       "VACUUM",    # purple
                       "4C_VACUUM", # orange
                       "QC")        # yellow 
col_time <- brewer.pal(8, name = "Set3")
names(col_time) <- c("1d",
                      "1w",
                      "2d",
                      "2h",
                      "3d",
                      "6h",
                      "2w",
                      "QC")        
                      
```

```{r pos-data_pos, message = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_pos_read_raws.RData"))}
#' Read the data
data_pos <- readMSData(paste0(MZML_PATH, "/", pd_pos$mzML_file),
                       pdata = as(AnnotatedDataFrame(pd_pos),
                                  "NAnnotatedDataFrame"), mode = "onDisk")
data_pos <- filterRt(data_pos, rt = c(0, rt_cut))
#' Add the time stamp from the individual files and check if they
#' match the injection index
time_stamp <- extract_time_stamp(fileNames(data_pos))
data_pos$time_stamp <- time_stamp
stopifnot(!is.unsorted(time_stamp))
save(data_pos, file = paste0(RDATA_PATH, "data_pos_read_raws.RData"))
```

```{r, echo = FALSE}
load(paste0(RDATA_PATH, "data_pos_read_raws.RData"))
sample_colors <- col_storage[as.character(data_pos$storage)]
```

All samples of the experiment are listed below.

```{r pos-phenodata, message = FALSE, results = "asis", echo = FALSE}
tab <- pData(data_pos)[, c("mzML_file", "storage", "time")]
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Data files and samples for positive polarity"))
```

In this project mitra tips, that were used to collect blood samples, were
stored unter the following 5 conditions:
RT = at room temperature
BAG = in a plastic bag that contains dessicants
4C_BAG = in a plastic bag that contains dessicants, stored at 4°C
VACUUM = in a vacuum bag
4C_VACUUM = in a vacuum bag, stored at 4°C
The second factor in the data set is time, which describes for how long the 
mitra tips were stored starting with 2 hours up to 2 weeks.

Next we perform an initial quality assessment by comparing the distribution of
BPC values from the spectra between all samples.

## Base peak chromatogram

Data coming from LC-MS experiments are usually analyzed along the retention time
axis. MS data is organized by spectrum and hence orthogonally to the retention
time axis. The `chromatogram` allows to extract intensities along retention time
by *aggregating* the signal within each spectrum. When the `aggregationFun`
parameter of this function is set to `"sum"`, we create a Total Ion Chromatogram
(TIC), which shows the sum of all signal intensities per spectrum *vs.*
retention time, whereas if we set the `aggregationFun` to `"max"`, we generate a
Base Peak Chromatogram, which is a chromatogram obtained by plotting the
intensity of the base peak (i.e. the maximal signal in a spectrum) detected in
each of a series of mass spectra recorded as a function of retention time
[@Gross:2017ms]. The same function can also be used to generate Extracted Ion
Chromatograms (EIC), which contain the signal from a specific m/z range and RT
window.

```{r pos-calc-tic, message = FALSE, eval = !file.exists(paste0(RDATA_PATH, "chrs_bpc_raw.RData"))}
#chrs_tic <- chromatogram(data_pos, aggregationFun = "sum")
gc()
register(SerialParam())
chrs_bpc <- chromatogram(data_pos, aggregationFun = "max")
save(chrs_bpc, file = paste0(RDATA_PATH, "chrs_bpc_raw.RData"))
```

```{r, echo = FALSE}
load(paste0(RDATA_PATH, "chrs_bpc_raw.RData"))
```

The base peak chromatogram for the full experiment is shown below.

```{r pos-bpc-plot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 5, fig.cap = "Base peak chromatograms for all samples of the experiment (positive polarity)."}
plot(chrs_bpc, col = paste0(col_storage[chrs_bpc$storage], "60"))
legend("topright", col = col_storage, legend = names(col_storage), lwd = 2)
```

The base peak chromatograms are quite different between the different sample
storage methods. Mitra tips that were stored in plastic bags at room temperature
show a higher signal in the retention time range from 30 to 100 seconds. In the
retention time range from 110 to 130 the signals are not perfectly aligned, 
some samples show a higher intensity then others and we observe some variation
in retention time. For most other parts the BPC shows similar signal suggesting
that similar compounds are detected. 

We next cluster samples based on pair-wise correlations of their (log2) base 
peak intensities.

## Heatmap

Another tool that lets us evaluate the behaviour of our datasets is the heatmap.
Heatmaps are a graphical representation of the data where the individual values
contained in a matrix are represented by colours; in this case,the intensity of
the signal is coupled with hierarchical clustering.
The first step of the analysis requires the use of the `bin` function: this
aggregates intensity values belonging to the same bin (m/z range) and sums
them all together. The clustering was performed using complete linkage
hierarchical clustering on the pairwise correlations of the binned BPC, such
that there is maximal intercluster dissimilarity.
The `cor` function is then used to calculate the correlation of the log2
transformed base peak signals and names are assigned to each row.
Finally, the `cutree` function identifies the number of clusters in which
columns are divided. In the resulting heatmap, the darker is the colour, the
more similar the base peak chromatogram of two samples is.

```{r pos-bin-chr, echo = FALSE, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 12, fig.cap = "Samples clustered by base peak chromatogram. Clustering bases on complete linkage hierarchical clustering of pairwise correlations of log2 base peak signals."}
#' First we have to bin the chromatograms to force them having the same
#' retention times.
chrs_bin <- MSnbase::bin(chrs_bpc)
#' Calculating the correlation on the log2 transformed bp signals
cormat <- cor(log2(do.call(cbind, lapply(chrs_bin, intensity))))
colnames(cormat) <- rownames(cormat) <- sampleNames(data_pos)
ann <- pData(data_pos)[, c("storage", "time")]
res <- pheatmap(cormat, annotation_col = ann,
                annotation_color = list(storage = col_storage))
```

The base peak chromatograms does not cluster by storage method, only the 
quality control (QC) samples are clustered together. On the other hand a 
clustering effect due to the storage duration can be observed, the samples
that were stored for a longer period of time (1-2 weeks) are clustered mainly
together and also the samples that were stored for only a couple of hours
tend do cluster together based on their base peak intensities.


## Boxplots and RLA-values

The next assessment is based on boxplots where we evaluate the distribution of
base peak and total ion values per sample and it aims at identifying problematic
samples, due to many reasons, such as a failed injection or problems that
occurred during sample preparation. Boxplots are created starting from the
distribution of TICs divided per files. Log2 transform is then applied to the
signal intensities in order to better see the differences and to have a more
similar variance across the range (which doesn't happen in the case of natural
scale).

In addition we calculate per-sample RLA (relative log abundance)
[@DeLivera:2012bw] values representing average log2 signal (either base peak or
total ion) of each sample relative to the median log2 signal of all samples
within the same group. The per sample RLA values help to spot samples with an
overall different average signal compared to all other samples within the same
sample group, which is in our case the sample source.

```{r pos-bpc-boxplot, message = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 6, fig.cap = "Distribution of the spectras' base peak signal per sample (top) and average RLA of base peak signals per sample (bottom). Potential outlier samples identified based on their base peak intensities are indicated with squares."}
bpcs <- lapply(chrs_bpc, intensity)
xl <- c(1, length(bpcs))
par(mfrow = c(2, 1), mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(bpcs, log2), col = paste0(col_storage[chrs_bpc$storage], 60),
        pch = NA, xaxt = "n", ylab = expression(log[2]~base~peak~intensity),
        xlim = xl)
grid(nx = NULL)
par(mar = c(3, 4.3, 0.5, 0.1))
bpcs_rla <- rla(vapply(bpcs, mean, numeric(1)), f = chrs_bpc$storage)
pch <- rep(16, length(bpcs_rla))
plot(bpcs_rla, xlab = "", ylab = "average RLA", xlim = xl,
     col = paste0(col_storage[chrs_bpc$storage], 80), pch = pch)
grid(nx = NULL)
```

Overall seen, the signal is comparable between the samples. 


## Principal component analysis

Principal Component Analysis (PCA) is a data visualization method that allows us
to simplify the dataset by reducing the number of characteristics inside the
dataset itself; PCA identifies a small set of informative dimensions that
capture most variability of the dataset. PCA aims to best describe the dataset
with the least number of features, without losing any information.  This
analysis should confirm the results obtained in the heatmap.

```{r pos-bpc-pca-injection-idx, fig.path = IMAGE_PATH, fig.width = 10, fig.height = 10, fig.cap = "PCA of the base peak signal. Numbers indicate the injection index."}
pc <- prcomp(t(log2(do.call(cbind, lapply(chrs_bin, intensity)))),
             scale = FALSE, center = TRUE)
par(mfrow = c(2, 2))
plot_pca(pc, col = col_storage[as.character(data_pos$storage)],
         pc_x = 1, pc_y = 2, labels = data_pos$inj_idx)
legend("topleft", col = col_storage, legend = names(col_storage), lwd = 2, 
       cex=0.4)
plot_pca(pc, col = col_storage[as.character(data_pos$storage)],
         pc_x = 3, pc_y = 4, labels = data_pos$inj_idx)
legend("topleft", col = col_storage, legend = names(col_storage), lwd = 2, 
       cex=0.4)
plot_pca(pc, col = col_storage[as.character(data_pos$storage)],
         pc_x = 2, pc_y = 3, labels = data_pos$inj_idx)
legend("topleft", col = col_storage, legend = names(col_storage), lwd = 2, 
       cex=0.4)
```

Looking at the PC1 plot, we see that all QC samples are clustered together,
whereas it is hard to differentiate between the different storage methods.

We then redo the PCA analysis but colour the samples according to storage 
duration (time):

```{r pos-bpc-pca-injection-idx-time, fig.path = IMAGE_PATH, fig.width = 10, fig.height = 10, fig.cap = "PCA of the base peak signal. Numbers indicate the injection index."}
pc <- prcomp(t(log2(do.call(cbind, lapply(chrs_bin, intensity)))),
             scale = FALSE, center = TRUE)
par(mfrow = c(2, 2))
plot_pca(pc, col = col_time[as.character(data_pos$time)],
         pc_x = 1, pc_y = 2, labels = data_pos$inj_idx)
legend("topleft", col = col_time, legend = names(col_time), lwd = 2, 
       cex=0.4)
plot_pca(pc, col = col_time[as.character(data_pos$time)],
         pc_x = 3, pc_y = 4, labels = data_pos$inj_idx)
legend("topleft", col = col_time, legend = names(col_time), lwd = 2, 
       cex=0.4)
plot_pca(pc, col = col_time[as.character(data_pos$time)],
         pc_x = 2, pc_y = 3, labels = data_pos$inj_idx)
legend("topleft", col = col_time, legend = names(col_time), lwd = 2, 
       cex=0.4)
```

In this plot, we see that the QC are clustered together, but also the samples
that were stored for 6h are in one cluster in PC1. Samples that were stored for 
2 days are also mainly clustered together, the same can be observed for samples
stored for 2 weeks.


## Chromatographic peak detection

Key parameters for the *centWave* [@Tautenhahn:2008fx] chromatographic peak
detection algorithm are `ppm` and `peakwidth`, the first defining the allowed
scattering in m/z dimension of valid chromatographic peaks and the second
defining the lower and upper bound of chromatographic peak width (in
seconds). We empirically determined the *best* values for these parameters by
evaluating the raw MS data for selected known compounds in QC samples. We load
below the most likely adduct and the expected retention time for the standards
defined in [this
repository](http://github.com/EuracBiomedicalResearch/lcms-standards).

```{r known-cmps, warning = FALSE}
library(Rdisop)
library(MetaboCoreUtils)
std_info <- read.table(
"https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/standards_dilution.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
std_info <- std_info[!is.na(std_info[, "POS"]), ]
std_info <- std_info[order(std_info$name), ]
std_info$mzneut = NA
std_info$mz_ion = NA
for (i in seq(nrow(std_info))) {
    if (grepl("C", std_info$formula[i]))
        std_info$mzneut[i] <- getMolecule(std_info$formula[i])$exactmass
    else
        std_info$mzneut[i] = as.numeric(std_info$formula[i])
    ## Calculate also the m/z
    std_info$mz_ion[i] <- mass2mz(std_info$mzneut[i],
                                  adduct = std_info[i, "POS"])[1, 1]
}
```

A `ppm = 50` was determined by a previous analysis (not shown here) that based
on the respective example in the
[metabolomics2018](https://github.com/jorainer/metabolomics2018) workflow. The
setting for the `peakwidth` parameter (`peakwidth = c(2, 20)`) was based on a
similar analysis of the present, and on other data sets employing the same LC
setup.

```{r pos-centWave, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_pos_pks.RData"))}
cwp <- CentWaveParam(ppm = 50,
                     peakwidth = c(2, 20),
                     snthresh = 10,
                     mzdiff = 0.001,
                     prefilter = c(3, 800),
                     noise = 100,
                     integrate = 2)
data_pos <- findChromPeaks(data_pos, param = cwp)
save(data_pos, file = paste0(RDATA_PATH, "data_pos_pks.RData"))
```

We start the process by applying the `centWave` algorithm, which first identifies
Regions Of Interest (ROI) in the m/z domain, then applies a Continuous Wavelet
Transform to detect chromatographic peaks [@Tautenhahn:2008fx]. This algorithm
allows us to change many parameters to optimize the analysis. The parameters
are: \
- `ppm`, which describes the tolerance in m/z deviation to consider a peak
  to belong to the same ion \
- `peakwidth`, a parameter that limits the width of a peak, calculated in
  seconds \
- `snthresh`, which defines a signal-to-noise value under which no peaks are
  detected \
- `prefilter`, used to remove peaks with a lower intensity than a set threshold
- `mzCenterFun`, which is a function that calculates the m/z center of the
  chromatographic peak \
- `integrate`, which defines the method used to define the boundaries of the
  chromatographic peak \
- `mzdiff`, a value that indicates the m/z difference that two peaks must have to
  be considered different, even though they have the same retention time \
- `fitgauss`, which allows fitting a Gaussian curve on the detected peaks \
- `noise`, an absolute amount below which no peaks will be considered \
- `verboseColumns`, which allows for additional peak metadata columns to be
  returned \
- `roiList`, a list of ROIs containing detected mass traces, which allows to
  skip the first part of the analysis, thus using the submitted list to carry
  out the peak detection step \
- `firstBaselineCheck`, permits a check that data in the ROIs are above the first
  baseline \
- `roiScales`, numeric vector of equal length to roiList, to be used to define the
  scale for each region of interest

The centWave parameters for the current LC-MS setup have been evaluated and
defined in another analysis employing the same setup. They are the following: \
- *ppm* = 50 \
- *peakwidth* = 2, 20 \
- *snthresh* = 10 \
- *prefilter* = 3, 800 \
- *mzCenterFun* = "wMean" \
- *integrate* = 2 \
- *mzdiff* = 0.001 \
- *fitgauss* = FALSE \
- *noise* = 100 \
- *verboseColumns* = FALSE \
- *roiList* = Listlength 0 \
- *firstBaselineCheck* = TRUE \
- *roiScales* = 0

We apply then the `findChromPeaks` function to detect chromatographic peaks.

```{r pos-centWave-cached, echo = FALSE, eval = file.exists(paste0(RDATA_PATH, "data_pos_pks.RData"))}
load(paste0(RDATA_PATH, "data_pos_pks.RData"))
n_peaks_before <- nrow(chromPeaks(data_pos))
```

After finding peaks, we must perform some post-processing in order to remove so
called *peak detection artifacts* which arise during peak detection and comprise
artificially split chromatographic peaks or largely overlapping peaks. The
`refineChromPeaks` function in combination with `MergeNeighboringPeaksParam`
enables to reduce the number of such artifacts by merging peaks that have
similar retention time and mass-to-charge ratio.

```{r pos-centWave-refine, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_pos_refined.RData"))}
mnp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4)
data_pos <- refineChromPeaks(data_pos, param = mnp)
save(data_pos, file = paste0(RDATA_PATH, "data_pos_refined.RData"))
```

```{r, eval = file.exists(paste0(RDATA_PATH, "data_pos_refined.RData")), echo = FALSE}
load(paste0(RDATA_PATH, "data_pos_refined.RData"))
```

Merging neighboring peaks reduced the total number of peaks in the
data set from `r n_peaks_before` to `nrow(chromPeaks(data_pos))`.

The result of the chromatographic peak detection is an `XCMSnExp` object which
contains all preprocessing results. For each identified peak, the m/z (`"mz"`),
retention time (`"rt"`), the range of RT and m/z (`"rtmin"`, `"rtmax"`,
`"mzmin"`, `"mzmax"`), the integrated signal of the peak (`"into"`), the maximal
signal of the peak (`"maxo"`), the signal to noise ratio (`"sn"`) and the index
of the sample in which the peak was identified (`"sample"`) are reported.

In the following loop, we evaluate the peak detection performance on the
Extracted Ion Chromatograms (EICs) of ions from our lab-internal set of
standards, which consists of molecules that are supposed to be present in human
serum samples. First we define the respective m/z and RT ranges and subsequently
extract the chromatograms. A solid black vertical line is drawn to indicate the
theoretical retention time.

```{r pos-centWave-eic-plots, echo = FALSE, eval = plot_eics}
#' Identify chromatographic peaks with their apex position within the
#' theoretical retention time of a standard +/- 30seconds and with a mzmed
#' matching the m/z of the standard's ion with an acceptable difference of
#' 50 ppm. We're extracting the m/z and retention time range for these
#' chromatographic peaks
std_info_mz_rt <- chromPeakArea(data_pos, mz = std_info$mz_ion,
                                rt = std_info$RT, diffRt = 30,
                                ppm = 50)
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[as.character(data_pos$storage)]
for (i in 1:nrow(std_info)) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_POS.png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    abline(v = std_info$RT[i])
    dev.off()
}
```

All the plotted EICs have been visually inspected in order to find the most
interesting peaks that could indicate which compounds might be the most
interesting for our analysis. During this process, we annotated the observed RT,
whether the peak was ok or not and some additional notes about the shape of the
peak: these observations have been manually inserted in a table, where each line
represents each of the peaks discovered through the preliminary peak detection
run.

```{r pos-centWave-manual-check, echo = FALSE, eval = FALSE}
#' Go manually through all generated plots above and determine which peaks
#' look OK.
std_info$RT_obs <- NA_real_
std_info$is_ok <- FALSE
std_info$peak_note <- NA_character_
write.table(std_info, file = "data/std_info_2.txt", row.names = FALSE, sep = "\t")
```

The observations made for each compound are written in the
*std_info_pos.txt* file, which is then loaded and it is used to continue
the study. 

Next, we want to import the collected data and we extract the chromatograms
where the peak from the standards and the experimental data overlap in the
retention time dimension. In the resulting chromatograms, we annotate rt_min and
rt_max; also, the observed retention time is depicted with a black vertical
dashed line.

```{r pos-centWave-manual-check-import, echo = FALSE}
std_info <- read.table("data/std_info_pos_check.txt", sep = "\t", as.is = TRUE,
                       header = TRUE, dec = ".")
std_info$mz_ion <- as.numeric(std_info$mz_ion)
std_info <- std_info[std_info$is_ok, ]
std_info_mz_rt <- chromPeakArea(data_pos, mz = std_info$mz_ion,
                                rt = std_info$RT_obs, diffRt = 1, ppm = 10,
                                type = "any")
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
```


```{r pos-centWace-eics-refined, echo = FALSE, eval = plot_eics, warning = FALSE, message = FALSE}
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 5
rtr[, 2] <- rtr[, 2] + 5
std_info_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[data_pos$storage]
for (i in seq_len(nrow(std_info))) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_POS.png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    #' This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    ## abline(v = std_info$RT[i])
    abline(v = std_info$RT_obs[i], lty = 2)
    dev.off()
}
```

Likewise as the previous case, we find different looking peaks, though they are
all plausible features that will be identified in later steps of this research.

```{r echo = FALSE, eval = TRUE}
## Plot EICs for peaks that were merged by the *refinement* step.
load(paste0(RDATA_PATH, "data_pos_pks.RData"))
data_pos_pks <- data_pos
load(paste0(RDATA_PATH, "data_pos_refined.RData"))
merged_rand <- sample(which(chromPeakData(data_pos)$merged), 100)
dr <- paste0(IMAGE_PATH, "random_merged_peaks/")
dir.create(dr, showWarnings = FALSE)
for (i in merged_rand) {
    pk <- chromPeaks(data_pos)[i, , drop = FALSE]
    rtr <- pk[1, c("rtmin", "rtmax")] + c(-10, 10)
    mzr <- pk[1, c("mzmin", "mzmax")] + c(-0.005, 0.005)
    chr_1 <- chromatogram(filterFile(data_pos_pks, pk[1, "sample"]),
                          rt = rtr, mz = mzr)
    chr_2 <- chromatogram(filterFile(data_pos, pk[1, "sample"]),
                          rt = rtr, mz = mzr)
    png(file = paste0(dr, rownames(pk), ".png"), width = 12, height = 12,
        units = "cm", res = 300, pointsize = 4)
    par(mfrow = c(2, 1))
    plot(chr_1, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
         peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
    plot(chr_2, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
         peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
    dev.off()
}
```

Results from the peak merging were validated manually by inspecting 100 random
merged peaks. In most cases merging resulted in better peak integration. Most
importantly, peak merging removes any completely overlapping peaks which would
result in the correspondence analysis to artificially inflated quantified
feature abundances (if `method = "sum"` is used).

For the in total `r nrow(std_info)` standards for which retention times have
been determined (in water), `r sum(std_info$is_ok)` are considered *detected* in
the present data set after manually inspecting the detected peaks close to the
expected retention time.

The table below summarizes the results of the chromatographic peak detection for
the list of these *known compounds*.

```{r pos-known-compounds-peak-summary, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
std_info <- std_info[std_info$is_ok, , drop = FALSE]
#' Calculate summaries on peaks overlapping an MS slice.
#'
#' @return
#'
#' `numeric()` with:
#' - average rt peak width `"rt_width"`
#' - average mz peak width `"mz_width"`
#' - average mz peak width in ppm `"mz_width_ppm"`
#' - average difference of the peak m/z to the theoretical m/z in ppm `"mz_ppm"`
#' - number of samples in which more than one peak was found `"multi_pk_count"`
#' - percentage of samples within each group in which a peak was found.
slice_peak_summary <- function(rtr, mzr, mz = NULL, x, group, ppm = 10) {
    if (missing(group))
        group <- rep("all", length(fileNames(x)))
    group <- factor(group, levels = unique(group))
    if (missing(x))
        stop("'x' has to be submitted.")
    pks <- chromPeaks(x, rt = rtr, mz = mzr, ppm = ppm)
    if (nrow(pks)) {
        pks <- cbind(pks,
                     rt_width = pks[, "rtmax"] - pks[, "rtmin"],
                     mz_width = pks[, "mzmax"] - pks[, "mzmin"])
        pks <- cbind(pks,
                     mz_width_ppm = pks[, "mz_width"] * 1e6 / pks[, "mz"])
        if (length(mz))
            mz_ppm <- mean(abs(pks[, "mz"] - mz) * 1e6 / mz)
        else mz_ppm <- NA_real_
        #' Number of samples in which multiple peaks were identified.
        pk_cnt_smpl <- table(factor(pks[, "sample"],
                                    levels = 1:length(fileNames(x))))
        #' Percentage per source in which a peak was identified.
        pk_perc <- split(as.numeric(pk_cnt_smpl), group)
        percs <- unlist(lapply(pk_perc, function(z) 100 * sum(z > 0) / length(z)))
        c(rt_width = mean(pks[, "rt_width"]),
          mz_width = mean(pks[, "mz_width"]),
          mz_width_ppm = mean(pks[, "mz_width_ppm"]),
          mz_ppm = mz_ppm,
          multi_pk_count = sum(pk_cnt_smpl > 1),
          percs)
    } else {
        percs <- rep(NA_real_, length(unique(group)))
        names(percs) <- unique(group)
        c(rt_width = NA_real_, mz_width = NA_real_, mz_width_ppm = NA_real_,
          mz_ppm = NA_real_, multi_pk_count = NA_real_, percs)
    }
}
#' Iterate through rows to determine statistics for samples:
std_info_pks <- vector("list", nrow(std_info))
for (i in 1:nrow(std_info)) {
    rtr <- std_info$RT_obs[i] + c(-7, 7)
    mzr <- std_info$mz_ion[i]
    res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
                              data_pos, data_pos$storage, ppm = 50)
    if (is.na(res[1]))
        res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
                                  data_pos, data_pos$storage, ppm = 100)
    std_info_pks[[i]] <- res
}
std_info_pks <- data.frame(name = std_info$name, do.call(rbind, std_info_pks),
                           stringsAsFactors = FALSE)
std_info_pks$delta_rt <- std_info$RT_obs - std_info$RT
pandoc.table(std_info_pks, style = "rmarkdown",
             caption = paste("Summary for identified chromatographic peaks of",
                             "the known compounds. Columns rt_width, mz_width",
                             "and mz_width_ppm show the mean widths in",
                             "retention time and m/z dimension of the",
                             "peaks, mz_ppm the average difference between",
                             "the peaks' m/z and the theoretical m/z of the",
                             "ion, multi_pk_count the number of samples in",
                             "which more than one peak was identified",
                             "in the rt region and the remaining columns",
                             "the percentages of samples per group in which",
                             "a peak was identified. Columnn delta_rt ",
                             "contains the difference between the observed ",
                             "and the expected retention time."))
write.table(std_info_pks, file = "data/std_info_summary_id_peaks.txt", row.names = FALSE, sep = "\t")
```

Next we evaluate the numbers of detected peaks, m/z and retention time widths of
the peaks and the distribution of integrated peak signals in all samples.

```{r pos-peaks-summary-plot, warning = FALSE, message = FALSE, fig.cap = "Summaries of identified chromatographic peaks. Shown are the number of detected peaks, their m/z widths and their integrated signal in each measured sample.", fig.width = 12, fig.height = 10, fig.path = IMAGE_PATH}
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_pos),
                            chromPeaks(data_pos)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
    cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
          mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
          rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
        col = paste0(col_storage[data_pos$storage], 80),
        ylab = "peak count", main = "Peak detection summary, POS",
        ylim = c(0, 10000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_storage, pch = 15,
       legend = names(col_storage))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
        ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
        col = paste0(col_storage[data_pos$storage], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_pos$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
        ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
        col = paste0(col_storage[data_pos$storage], 80))

```

The numbers of detected peaks is between 5000 and 6000 with more peaks being
found samples stored in bags at 4°C, which is also the storage method showing
the highest variability in the numbers of identified peaks.
The m/z widths of identified peaks is on average below 10ppm. The distribution
of integrated peak signals between samples is also highly similar.

The table below shows the per-sample median values summarized per source type.

```{r pos-peaks-summary-table, echo = FALSE, message = FALSE, results = "asis"}
#' Calculate per sample mean of
#' - peak count
#' - m/z width
#' - rt width
#' Aggregate these per sample group.
smpl_summary <- cbind(peak_count = vapply(pk_list, nrow, numeric(1)),
                      do.call(rbind, lapply(pk_list, function(z) {
                          c(median_mz_width = median(z[, "mz_width_ppm"]),
                            median_rt_width = median(z[, "rt_width"]))
                      })))
tab <- aggregate(smpl_summary, by = list(storage = data_pos$storage), quantile)
rownames(tab) <- tab[, 1]
tab <- tab[, -1]
pandoc.table(t(tab), style = "rmarkdown", 
             cap = paste("Summary of peak detection results. Shown are the",
                         "per-source quantiles of the numbers of identified",
                         "peaks, of the median m/z (in ppm) and rt widths",
                         " per sample."))
```

The per-sample median m/z width of the identified peaks is on average quite
low and consistent across sample types, same as the retention time width. The
only apparent differences are for the numbers of detected peaks. Here plasma
samples show the lowest and venous samples the highest numbers.

### Summary

On average about 5500 chromatographic peaks were identified per sample, with the
median m/z width of these peaks being quite small.

## Alignment

Alignment is a crucial step in the process of data analysis because there may
be shifts in retention time in the different analyzed samples. These shifts
find their origin in environmental conditions, such as temperature and pressure
that can slightly change in the course of the measurements, or in the
equipment used, for instance, the composition of the mobile phase or the
stationary phase utilized in the chromatography stage. During alignment, we want
to make sure that the retention time is always the same for all peaks pertaining
to one feature, across multiple samples.
In `xcms` a robust method is implemented to carry out alignment: We will use the
*peak groups* method, that aligns samples based on *hook* peaks that are present
in most samples. We thus first group chromatographic peaks requiring them to be
present in 80% of the samples within each group and use these as the *hook*
peaks. Most of the settings for the peak grouping can then be reused for the
correspondence analysis in the next section. Note that before alignment we
remove potentially problematic samples. 

First of all, we group peaks among samples, as we do for the correspondence
step; we use a 0.01 `binSize` to extract all chromatographic peaks from
very small m/z windows, to ensure proper separation of peaks, even if they are
very close in m/z. This has been defined by evaluating
the distance in m/z between chromatographic peaks in the same file in a region
with a high peak density (see plot below). We also set `minFraction` to 0.95 to exclude those peaks
that are found in less than 95% of samples and `bw` to 2 as the standard
deviation of the smoothing kernel.

Then, we specify the subset that we want to perform alignment on, the `"POOL"`
group, and we assign `"average"` to the `subsetAdjust` parameter; this leads to
an adjustment of non-subset samples based on how much the retention time of the
previous and following subset samples is shifted.


```{r pos-mz-distance-peaks-plot, message = FALSE, warning = FALSE, fig.cap = "Position of detected chromatographic peaks within a sample. Shown are chromatographic peaks in a region with high peak density. The horizontal blue line represents the bin width if binSize = 0.02 was used.", fig.path = IMAGE_PATH}
plotChromPeaks(filterMz(data_pos, mz = c(756, 758)), 1)
abline(h = c(757, 757.01), col = "#0000ff80")
```

To define the `bw` parameter, the other important parameter to the peak
density-based peak grouping, we evaluate the impact of different values on an
extracted ion chromatogram with several consecutive peaks. Such MS data slices
can be identified by visualizing the position of identified peaks on the 2
dimensional MS data map with the `plotChromPeaks` function. In general, the `bw`
parameter should be defined in a way that allows separation of peaks that
represent signal from different compounds.

```{r pos-bw-definition-plot, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result on a m/z slice containing the Fructose and Mannose peaks. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks in that slice along the retention time axis (y-axis lists samples). The black line shows the density distribution for a bw = 1.3, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8, fig.path = IMAGE_PATH}
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
                          peak_type = "point", lwd = 1, ...) {
    if (missing(rt))
        rt <- range(rtime(x))
    chr_tmp <- chromatogram(x, mz = mz, rt = rt)
    col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
    plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
                         col = paste0(col, 60),
                         peakCol = paste0(col_tmp, 40),
                         peakBg = paste0(col_tmp, 10))
}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
              col = col_storage[data_pos$storage])
pdf(file = paste0(IMAGE_PATH, "glucose_0.8.pdf"), height = 7, width = 5)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 1.3)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
              col = col_storage[data_pos$storage])
```

With a smoothing bandwidth `bw = 1.3` we are able to separate the Fructose and
Mannose peak (see plot above). However, because peak detection failed separating
peaks for the above example especially in plasma samples (data not shown) and
because in the present analysis, due to the comparison of different matrices, we
put less emphasis in the quantification of specific isomers, we relax this
criteria and accept grouping of isomers into the same feature. We use a `bw = 2`
which reduces the number of features for the later analysis (and by potentially
grouping isomers into the same feature also the specificity of the analysis).

```{r pos-bw-definition-plot-2, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result on a m/z slice containing the Fructose and Mannose peaks. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks in that slice along the retention time axis (y-axis lists samples). The black line shows the density distribution for a bw = 2, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(160, 170)
pdp_tmp <- PeakDensityParam(sampleGroups = data_pos$storage, bw = 2)
plot_grouping(data_pos, mz = mzr, rt = rtr, param = pdp_tmp,
              col = col_storage[data_pos$storage])
```

In addition we evaluate the bandwidth setting on the peaks for 1-Methylhistidine
and 3-Methylhistidine.

```{r pos-bw-definition-plot-3, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result for Methylhistidine. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks for 1-Methylhistidine and 3-Methylhistidine (y-axis lists samples). The black line shows the density distribution for a bw = 2, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8, fig.path = IMAGE_PATH}
mzr <- std_info[std_info$HMDB.code == "HMDB0000001", "mz_ion"] + c(0.002, -0.002)
rtr <- c(170, 200)
plot_grouping(data_pos, rt = rtr, mz = mzr, param = pdp_tmp,
              col = col_storage[data_pos$storage])
```

With a `bw = 2` peaks for 1-Methylhistidine and 3-Methylhistidine are not
grouped into the same feature. 

We perform a subset alignment that is based on the alignment of the
QC samples. While the QC samples might not be representative for all matrices,
we still assume that they might still be able to estimate the retention time
shifts for study samples. For the alignment we require a *hook* peak to be
present in at least 95% of QC samples. We also increase the smoothing parameter
for the loess function (`span = 0.3`). With the default value of `span = 0.2`
alignment resulted in spectra within some files to be not ordered by retention
time anymore. Setting the parameter `extraPeaks = 50` ensured *hook* peaks not
being discarded because of the grouping of additional peaks within the same
sample to the same feature. Setting this parameter to a large value resulted in
*hook* peaks that span almost the full retention time range.

```{r pos-alignment-group, message = FALSE, warning = FALSE}
#' Remove potentially problematic samples. These were manually defined.
#' bad_idx <- c(74, 178, 166, 167, 39, 187, 169, 106)
#' data_pos <- filterFile(data_pos, file = seq_along(data_pos$sample)[-bad_idx])
#' define the peak grouping parameters to define the hook peaks
#' These should be peaks present in most samples
pdp <- PeakDensityParam(sampleGroups = data_pos$storage,
                        minFraction = 0.95,
                        minSamples = 5,
                        binSize = 0.01,
                        bw = 2)
data_pos <- groupChromPeaks(data_pos, param = pdp)
#' Next we perform the alignemnt.
pgp <- PeakGroupsParam(minFraction = 0.95, extraPeaks = 50, span = 0.3,
                       subsetAdjust = "average",
                       subset = which(data_pos$storage == "QC"))
data_pos <- adjustRtime(data_pos, param = pgp)
```

The results from the alignment are shown below. The base peak chromatograms are
slightly more overlapping after alignment. Also, adjustment of retention time is
smaller 5 seconds for most of the signal.

```{r pos-alignment-rtime-plot, message = FALSE, warning = FALSE, echo = FALSE, fig.width = 12, fig.height = 10, fig.cap = "Alignment result. Shown are the raw base peak chromatogram, the base peak chromatogram after alignment and the difference between the adjusted and raw retention time. Grey dots indicate hook peaks on which the alignment based.", fig.path = IMAGE_PATH}
chr_raw <- chromatogram(data_pos, aggregationFun = "max", adjustedRtime = FALSE)
chr_adj <- chromatogram(data_pos, aggregationFun = "max")
par(mfrow = c(3, 1), mar = c(0, 4.3, 2, 0.1))
plot(chr_raw, col = paste0(col_storage[chr_raw$storage], 40),
     peakType = "none", main = "BPC, raw")
plot(chr_adj, col = paste0(col_storage[chr_raw$storage], 40),
     peakType = "none", main = "BPC, adjusted")
plotAdjustedRtime(data_pos, col = paste0(col_storage[data_pos$storage], 80),
                  peakGroupsPch = 1, peakGroupsCol = "#00000040")
```

At last we generate extracted ion chromatogram plots of the raw and adjusted
data for the list of known compounds. These are visually inspected to evaluate
the impact of the alignment. 

```{r pos-alignment-kc-plots, echo = FALSE, warning = FALSE, message = FALSE, eval = plot_eics}
#' For each standard, reduce to the peak with the highest intensity within
#' the observed rt +/- 7 seconds.
std_info_mz_rt_obs <- chromPeakArea(data_pos, mz = std_info$mz_ion,
                                    rt = std_info$RT_obs, diffRt = 1,
                                    ppm = 10, type = "any")
rtr <- cbind(std_info_mz_rt_obs[, "rtmin"] - 5,
             std_info_mz_rt_obs[, "rtmax"] + 5)
std_info_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt_obs[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "alignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_storage[data_pos$storage]
for (i in 1:nrow(std_info)) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_POS.png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    abline(v = std_info$RT_obs[i])
    abline(v = std_info$RT[i], lty = 3, col = "grey")
    dev.off()
}
```

Plots can be found in the folder "alignment".

```{r, echo = FALSE}
save(data_pos, file = paste0(RDATA_PATH, "data_pos_aligned.RData"))
```

We used the peak groups method for alignment that uses *hook* peaks expected to
be present in all samples for the alignment.

## Correspondence

Correspondence aims to group chromatographic peaks of the same ion across
samples. We re-use settings for the grouping performed already in the previous
section (i.e. the bandwidth parameter) but reduce the `minFraction` parameter to
allow definition of features that are present in fewer individuals.

```{r pos-correspondence, message = FALSE, warning = FALSE}
#' Define settings for the correspondence and perform the analysis
pdp <- PeakDensityParam(sampleGroups = data_pos$storage,
                        minFraction = 1/3,
                        minSamples = 3,
                        binSize = 0.015,
                        bw = 2.3)
data_pos <- groupChromPeaks(data_pos, param = pdp)
```

```{r pos-correspondence-kc-plots, echo = FALSE, warning = FALSE, eval = plot_eics, message = FALSE}
std_info_chr <- chromatogram(
    data_pos, mz = std_info_mz_rt_obs[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
dr <- paste0(IMAGE_PATH, "correspondence/")
dir.create(dr, showWarnings = FALSE)
#' Visualizing alignment results for known compounds.
for (i in seq_len(nrow(std_info))) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_POS.png")
    chr <- std_info_chr[i, ]
    #' Use a different color for each feature.
    n_fts <- nrow(featureDefinitions(chr))
    clrs <- brewer.pal(9, "Set1")[seq_len(n_fts)]
    fts <- featureDefinitions(chr)
    if (nrow(fts)) {
        pk_col <- rep("#000000", nrow(chromPeaks(chr)))
        for (j in seq_len(n_fts)) {
            pk_col[fts$peakidx[[j]]] <- clrs[j]
        }
        png(filename, width = 12, height = 10, units = "cm",
            res = 200, pointsize = 4)
        plotChromPeakDensity(chr, simulate = FALSE,
                             main = paste0(std_info$name[i], ": ",
                                           format(mz(chr)[1], digits = 6), "-",
                                           format(mz(chr)[2], digits = 6)),
                             peakCol = paste0(pk_col, 40),
                             peakBg = paste0(pk_col, "10"),
                             col = "#00000040")
        abline(v = std_info$RT[i], col = "#00000080", lty = 3)
        abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
    } else {
        png(filename, width = 12, height = 10, units = "cm",
            res = 200, pointsize = 4)
        plotChromPeakDensity(chr,
                             main = paste0(std_info$name[i], ": ",
                                           format(mz(chr)[1], digits = 6), "-",
                                           format(mz(chr)[2], digits = 6)),
                             param = pdp, col = "#00000040")
        abline(v = std_info$RT[i], col = "#00000080", lty = 3)
        abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
    }
    dev.off()
}
#' In addition find for each standard the *best* feature (i.e. closest mz
#' and rt.
std_info$feature_id <- NA_character_
for (i in seq_len(nrow(std_info))) {
    fts <- featureDefinitions(data_pos, mz = std_info$mz_ion[i], ppm = 50)
    rt_diff <- abs(fts$rtmed - std_info$RT_obs[i])
    fts <- fts[rt_diff < 7, ]
    mz_diff <- abs(fts$mzmed - std_info$mz_ion[i])
    std_info$feature_id[i] <- rownames(fts[order(mz_diff), ])[1]
}
```


The table below summarizes the results from the correspondence analysis.

```{r pos-correspondence-summary-table, echo = FALSE, message = FALSE, warning = FALSE, results = "asis"}
feat_summ <- featureSummary(data_pos, group = data_pos$storage)
#' Summarized the feature summary table by breaking it down to certain
#' categories that represent the total number of features, total number of
#' features with as well as fetures present in certain percentages of samples with the percentages defined with `percentages`.
#'
#' @param x `matrix` such as returned by the [featureSummary] function.
#'
#' @param percentages `numeric` defining the percentages for which counts
#'     should be reported.
#'
#' @return `matrix` with total counts of features and counts of features for
#'     which peaks have been found in certain percentages of samples. Rows
#'     `"multi"` refer to features for which multiple chromatographic peaks
#'     are present in a sample.
#'
#' @author Johannes Rainer
featureSummaryTable <- function(x, percentages = c(10, 25, 50, 90)) {
    #' Check input table.
    if (!is.matrix(x) ||
        !all(c("count", "multi_count", "multi_perc", "perc") %in% colnames(x)))
        stop("'x' is supposed to be a matrix as returned by the ",
             "'featureSummary' function")
    trues <- list(total = feat_summ[, "count"] > 0,
                  `single peaks` = feat_summ[, "multi_count"] == 0,
                  `multi peaks` = feat_summ[, "multi_perc"] > 0
                  )
    if (length(percentages)) {
        for (perc in percentages) {
            trues <- c(trues, list(feat_summ[, "multi_perc"] > perc))
        }
        names(trues) <- c("total", "single peaks", "multi peaks",
                          paste0("multi in > ", percentages, "% of samples"))
    }
    do.call(rbind, lapply(trues, function(is_true) {
        cnt <- c(count = sum(is_true))
        for (perc in percentages) {
            nms <- names(cnt)
            cnt <- c(cnt, sum(x[is_true, "perc"] > perc))
            names(cnt) <- c(nms, paste0("in > ", perc, "%"))
        }
        cnt
    }))
}
pandoc.table(featureSummaryTable(feat_summ), style = "rmarkdown", 
             caption = paste("Summary of the correspondence analysis. Shown",
                             "are counts of features, counts of features with",
                             "at least one samples in which multiple peaks",
                             "are present (column multi peaks) and counts",
                             "of features with different amount of samples",
                             "having multiple peaks."))
```

More than 60 % of the features are *single peak features*, i.e. have only a
single chromatographic peak assigned per sample. The number of features present
in more than 90 % of samples is low (about 0,0002 %). 

Next we evaluate the integrated signal for features in QC samples. This is
expected to be similar between QC samples. Differences can, besides batch
effects or injection order dependent effects, also be caused by differences in
the identified chromatographic peak boundaries. We thus extract below feature
intensities and subset these to QC samples.

```{r feature-vals-QC, message = FALSE}
#' We extract the integrated original signal and use the signal from the peak
#' with the larger signal for multi-peak features.
fmat <- featureValues(data_pos, value = "into", method = "maxint")
#' Subset to QC samples and remove features not present in 90% of the samples
fmat_qc <- fmat[, data_pos$storage == "QC"]
nsamp <- ncol(fmat_qc)
fmat_qc <- fmat_qc[apply(fmat_qc, MARGIN = 1,
                         function(z) (sum(!is.na(z)) / nsamp) >= 0.9), ]
```

Next we determine per-row differences that will be used to asses overall
similarity between replicates. In log2 scale, we calculate the maximal
difference (`M_range`) and, to avoid results being influenced by outliers,
differences between abundances after removing the lower and upper 1% of signals
(`diff_98`. These `M` values represent thus log fold change differences in
abundances.

```{r feature-vals-diff, message = FALSE}
#' Calculat maximal differences...
diff_fun <- function(z) {
    c(M_range = diff(range(z, na.rm = TRUE)),
      M_98 = unname(diff(quantile(z, probs = c(0.01, 0.99), na.rm = TRUE))),
      M_90 = unname(diff(quantile(z, probs = c(0.05, 0.95), na.rm = TRUE))))
}
QC_diffs <- t(apply(log2(fmat_qc), MARGIN = 1, FUN = diff_fun))
```

The table below lists the quantiles of these differences.

```{r feature-vals-diff-table, message = FALSE, echo = FALSE, results = "asis"}
tab <- apply(QC_diffs, MARGIN = 2, quantile)
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Overview of the abundance differences between",
                             "QC samples. Shown are quantiles for the M_range",
                             "(log2 difference between the most extreme values",
                             "for a feature), M_98 (log2 difference after",
                             "removing the top 1% and lowest 1% of values for",
                             "a feature) and M_90 (log2 difference after",
                             "removing the top and lowest 5% of values per",
                             "feature). The analysis bases on", nrow(QC_diffs),
                             "features."))
```

The plot below shows the distribution of log2 ratios in abundances and their
dependency on average abundance.

```{r feature-vals-diff-plot, echo = FALSE, fig.cap = "Distribution of log2 ratios in abundances between QC samples and their dependency on their average abundance.", fig.widht = 10, fig.height = 5, fig.path = IMAGE_PATH}
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 1))
boxplot(QC_diffs, ylab = expression(log[2]~abundance~ratio))
grid(nx = NA, ny = NULL)
plot(rowMeans(log2(fmat_qc), na.rm = TRUE), QC_diffs[, 1],
     xlab = expression(log[2]~average~abundance),
     ylab = expression(log[2]~abundance~ratio), pch = 16, col = "#00000060")
grid()
```

```{r save-data, echo = FALSE, results = "hide"}
save(data_pos, file = paste0(RDATA_PATH, "data_pos.RData"))
```

### Summary

# Session information

```{r}
sessionInfo()
```

# References